// so we want to make a .ino code which takes alt az and moves motor to achive the RPY to ALt Az. 
// 2 din ka kam hai . - just use the SF code & the logic part sooch lay - parallel , etc stuff ...  and mix karde 
// and then test out karle -> use ai_guide wala code and send alt az to it . and see the error. 


// arduino code.txt may bhi hai ..
// star_pointing gpt chat. 

// basically - we use the SF_code.ino for getting the Rpy from sensor . and we use the Pointing_concept -> which is ek ALT Az diya jaygaa
// and arduino has to catch it. and then range -> Alt_low , Alt_high. and then there is a logic -> read the Pitch and if pitch < Alt_low then move ALT motor clockwise until 
// its in range. so basically the motor move until it reach the target posi. 
// and there are other stuff like - move 1 step when closer , and parallel move both the motors and etc stuff - Run the RPY in parallel function , and in the main function just get the RPY value and make the motors move as per that . 
// or write the RPY calculation function in the main code . idk which is better. need to think.  

// so the Full-motor-code has 2 parts -> SF part . and logic part. 
// the logic part is given below - in flowchart. 
// the SF part is v.imp . so write a SF_code.ino - which simply gets the raw sensors values and does SF and gives RPY. 


// if near then less step move , if far then more step move.
// and it contineaouly iterates .

// and its like a range - (it dosent directly point to 0 deg)
// its like we move the motor to run till it achives a range of (-0.1 to 0.1)

// parallel how motor...

// i think we need to manually hardcode the offset values of mag in the .ino code - after doing mag calib. 
// and acc , gyro ka too direct hardcoded rahega. 


// motor concept -> 

// Alt Az ayga , and the range will become 
// int range = 0.1
// ALT_LOWER =  ALT - range
// ALT_UPPER =  ALT + range
// AZ_LOWER =  AZ - range
// AZ_UPPER =  AZ + range

// so if the ALT = 45.5 then the rangle will be 45.4 to 45.6. and if the sensor pitch is beween that range then it will not move.

// and after the both the targed range is achieved , the laserfade() function will be called to turn on the laser.


// entire flow likh ------------------------------------------
# ..... read sensor ,  parallel motor move , laser point , ......

setOutputTorque(true)
Coils stay ON â†’ motor locks position (useful when holding a laser steady) 
? idk to use this.  since we move motors as per sensors (consistently) and not just move some particular step and wait.


// for parallel motor movement - use cheapstepper ka .newmove(step) function . which is a non-blocking function. 

so  -> loop{

    read sensr value and use SF to get RPY

    if (pitch > alt_higer)
        motorA.newmove(1)
    else if (pitch < alt_lower)
        motorA.newmove(-1)
    else
        motorA.newmove(0)
    
    same for yaw.

    .run()
}

// so it reads RPY then both motors by one step. 


// so here again and again if we read the RPY after every loop then not good. 
// insted we can make another function paralley to calculate RPY. 
// idk if this is good or bad. need to think . since this above code is also looks good.  